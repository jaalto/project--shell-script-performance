FILE: t-command-grep-parallel.sh
# Q: Howabout using parallel(1) to speed up grep(1)?
# A: No, parallel won't help in typical cases. Use only with huge files.

FILE: t-command-grep.sh
# Q: In grep, is option --fixed-strings faster?
# A: Not real difference between --extended-regexp, --perl-regexp, --ignore-case

FILE: t-command-output-vs-process-substitution.sh
# Q: `cmd | while` vs `while ... done < <(process substitution)`
# A: No real difference. Process substitution preserves variables in loop.

FILE: t-command-pwd-vs-variable-pwd.sh
# Q: How much is POSIX `$PWD` faster than pwd(1)?
# A: $PWD is about 7x faster considering `pwd` is even bash built-in

FILE: t-dir-empty.sh
# Q: What is the fastest way to check empty directory?
# A: array+glob is faster than built-in `compgen`

FILE: t-dir-entries.sh
# Q: Fastest to get list of dirs: for vs compgen vs ls -d
# A: In general, simple ls(1) will do fine. No big differences.

FILE: t-file-copy-check-exist.sh
# Q: If you need a copy of file, should you test before copy?
# A: Yes, test existense of file before cp(1). Hardlinks are fast.

FILE: t-file-for-loop-vs-awk.sh
# Q: for-loop file-by-file to awk vs awk handling all the files?
# A: is is at least 2x faster to do it all in awk

FILE: t-file-glob-bash-compgen-vs-stat.sh
# Q: Sheck if GLOB matches file: arrays vs `compgen` vs stat(1)
# A: `compgen` and array+glob are slightly faster than stat(1)

FILE: t-file-grep-vs-match-in-memory.sh
# Q: To search file for matches: in memry searh vs grep(1)
# A: Fastest is to read file once into memory and then do matching

FILE: t-file-newest-in-dir.sh
# Q: What is the fastest way to get newest file in a directory
# A: Use find + filters. find + awk would be tad faster but more complex.

FILE: t-file-pipe-vs-process-substitution.sh
# Q: Would pipe be slower than using process substitution?
# A: No real difference. Pipes are efficient.

FILE: t-file-read-cat-vs-bash.sh
# Q: Howabout `$(< FILE)` vs `$(cat FILE)`
# A: It is abut 2x faster to use `$(< FILE)` for small files

FILE: t-file-read-content-loop.sh
# Q: To process lines: `readarray` vs `while read < file`
# A: It is about 2x faster to use `readarray`

FILE: t-file-read-match-lines-loop-vs-grep.sh
# Q: would grep(1) prefilter help before loop?
# A: grep(1) before loop is 2x faster than doing filtering in loop

FILE: t-file-read-shell-result.sh
# Q: Capturing command's output: `var=$()` vs reading from a temporary file?
# A: The `var=$()` is 2x faster than using a temporary file

FILE: t-file-read-with-size-check.sh
# Q: Is empty file check useful before reading file's content?
# A: It is about 10x faster to use `[ -s file ]` before reading

FILE: t-file-size-info.sh
# Q: What is the fastest way to read a file's size?
# A: Prefer GNU `wc -c`. The non-POSIX stat(1) and it's options are not portable.

FILE: t-function-return-value.sh
# Q: Howabout Bash nameref to return value vs val=$(funcall)
# A: It is about 40x faster to use nameref to return value from a function

FILE: t-lib.sh
FILE: t-statement-arithmetic-for-loop.sh
# Q: for-loop: `{1..N}` vs `$(seq N)` vs `((...))` vs POSIX `i++`
# A: The `{1..N}` and `$(seq N)` are very fast

FILE: t-statement-arithmetic-increment.sh
# Q: POSIX `i=$((i + 1))` vs `((i++))` vs `let i++` etc.
# A: No noticeable difference, POSIX Â´i=$((i + 1))` will do fine

FILE: t-statement-if-test-posix-vs-bash.sh
# Q: POSIX `[ $var = 1 ]` vs Bash `[[ $var = 1 ]]` etc
# A: In practise, no real differences

FILE: t-string-trim-whitespace.sh
# Q: Trim whitepace using Bash RE vs sed(1)
# A: Bash is much faster; especially with fn() using nameref

FILE: t-variable-array-split-string.sh
# Q: Split string into an array: `eval` vs `read`?
# A: It is about 2-3x faster to use `eval`

